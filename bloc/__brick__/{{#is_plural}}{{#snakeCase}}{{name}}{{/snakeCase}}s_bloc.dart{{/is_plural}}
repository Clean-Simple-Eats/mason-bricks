import 'dart:async';

import 'package:autoequal/autoequal.dart';
import 'package:bloc/bloc.dart';
import 'package:bloc_concurrency/bloc_concurrency.dart' as con;
import 'package:equatable/equatable.dart';
import 'package:{{#snakeCase}}{{{project}}}{{/snakeCase}}_application/utils/bloc_extensions.dart';
import 'package:{{#snakeCase}}{{{project}}}{{/snakeCase}}_domain/domain.dart';

import 'package:{{#snakeCase}}{{{project}}}{{/snakeCase}}_application/utils/persist_bloc.dart';

part '{{#snakeCase}}{{{name}}}{{/snakeCase}}s_bloc.g.dart';
part '{{#snakeCase}}{{{name}}}{{/snakeCase}}s_event.dart';
part '{{#snakeCase}}{{{name}}}{{/snakeCase}}s_state.dart';

// ignore: avoid_private_typedef_functions
typedef _Emitter = Emitter<{{#pascalCase}}{{{name}}}{{/pascalCase}}sState>;

class {{#pascalCase}}{{{name}}}{{/pascalCase}}sBloc
    extends PersistBloc<{{#pascalCase}}{{{name}}}{{/pascalCase}}sEvent, {{#pascalCase}}{{{name}}}{{/pascalCase}}sState> {
  {{#pascalCase}}{{{name}}}{{/pascalCase}}sBloc({
    required I{{#pascalCase}}{{{name}}}{{/pascalCase}}sCache {{#camelCase}}{{{name}}}{{/camelCase}}sCache,
    required I{{#pascalCase}}{{{name}}}{{/pascalCase}}sSource {{#camelCase}}{{{name}}}{{/camelCase}}sSource,
  })  : _{{#camelCase}}{{{name}}}{{/camelCase}}sCache = {{#camelCase}}{{{name}}}{{/camelCase}}sCache,
        _{{#camelCase}}{{{name}}}{{/camelCase}}sSource = {{#camelCase}}{{{name}}}{{/camelCase}}sSource,
        super(const _Loading()) {
    on<_Init>(_init);
    on<_Fetch>(_fetch, transformer: con.droppable());
    on<_CacheChanged>(_cacheChanged);
    on<_SourceChanged>(_sourceChanged);

    add(const _Init());
  }

  final I{{#pascalCase}}{{{name}}}{{/pascalCase}}sCache _{{#camelCase}}{{{name}}}{{/camelCase}}sCache;
  final I{{#pascalCase}}{{{name}}}{{/pascalCase}}sSource _{{#camelCase}}{{{name}}}{{/camelCase}}sSource;

  StreamSubscription<List<StreamResult<{{#pascalCase}}{{{name}}}{{/pascalCase}}>>>? _sourceListener;

  @override
  Future<void> close() {
    _sourceListener?.cancel();
    return super.close();
  }

  @override
  Future<Stream<{{#pascalCase}}{{{name}}}{{/pascalCase}}sState?>> listenForStorageChanges() async {
    final result = await _{{#camelCase}}{{{name}}}{{/camelCase}}sCache.watchAll();

    return result.asyncMap((event) {
      if (!state.isReady) {
        return null;
      }

      if (event.isFailure) {
        return null;
      }

      final {{#camelCase}}{{{name}}}{{/camelCase}}s = [...state.asReady.{{#camelCase}}{{{name}}}{{/camelCase}}s];

      if (event.wasDeleted) {
        {{#camelCase}}{{{name}}}{{/camelCase}}s.removeWhere((e) => e.id == event.key);
      } else {
        final value = event.value;

        if (value == null) {
          return null;
        }

        final index = {{#camelCase}}{{{name}}}{{/camelCase}}s.indexWhere((e) => e.id == event.key);

        if (index == -1) {
          {{#camelCase}}{{{name}}}{{/camelCase}}s.add(value);
        } else {
          {{#camelCase}}{{{name}}}{{/camelCase}}s[index] = value;
        }
      }

      return _Ready({{#camelCase}}{{{name}}}{{/camelCase}}s);
    });
  }

  @override
  void onStorageChanged({{#pascalCase}}{{{name}}}{{/pascalCase}}sState state) {
    if (state.isReady) {
      add(_CacheChanged(state.asReady));
    }
  }

  @override
  Future<void> persist({{#pascalCase}}{{{name}}}{{/pascalCase}}sState state) async {
    if (!state.isReady) {
      return;
    }

    final result = await _{{#camelCase}}{{{name}}}{{/camelCase}}sCache.all();

    if (result.isError) {
      return;
    }

    final all = result.value;

    final ids = state.asReady.{{#camelCase}}{{{name}}}{{/camelCase}}s.map((e) => e.id).toSet();

    final toDelete = all.fold(<String>{}, (previous, e) {
      if (!ids.contains(e.id)) {
        previous.add(e.id);
      }

      return previous;
    });

    if (toDelete.isNotEmpty) {
      await _{{#camelCase}}{{{name}}}{{/camelCase}}sCache.deleteAll(toDelete);
    }

    final toUpdate = <{{#pascalCase}}{{{name}}}{{/pascalCase}}>[];

    // check if any all have changed from state.asReady.all
    for (final e in state.asReady.{{#camelCase}}{{{name}}}{{/camelCase}}s) {
      if (!all.contains(e)) {
        toUpdate.add(e);
      }
    }

    if (toUpdate.isNotEmpty) {
      await _{{#camelCase}}{{{name}}}{{/camelCase}}sCache.saveAll(toUpdate);
    }
  }

  @override
  Future<{{#pascalCase}}{{{name}}}{{/pascalCase}}sState?> retrieve() async {
    final result = await _{{#camelCase}}{{{name}}}{{/camelCase}}sCache.all();

    if (result.isError) {
      return null;
    }

    return _Ready(result.value);
  }

  FutureOr<void> _cacheChanged(_CacheChanged event, _Emitter emit) async {
    emitNoCache(emit, event.state);
  }

  Future<void> _fetch(_Fetch event, _Emitter emit) async {
    emit(const _Loading());

    await _get{{#pascalCase}}{{{name}}}{{/pascalCase}}s(emit);
  }

  Future<void> _get{{#pascalCase}}{{{name}}}{{/pascalCase}}s(_Emitter emit) async {
    final result = await _{{#camelCase}}{{{name}}}{{/camelCase}}sSource.all();

    if (result.isError) {
      emitError(emit, _Error(result.error));
      return;
    }

    emit(_Ready(result.value));
  }

  Future<void> _init(_Init event, _Emitter emit) async {
    await hydrate(emit);

    await _get{{#pascalCase}}{{{name}}}{{/pascalCase}}s(emit);

    final stream = await _{{#camelCase}}{{{name}}}{{/camelCase}}sSource.watchAll();

    _sourceListener = stream.listen((changes) {
      if (!state.isReady) {
        return;
      }

      if (isClosed) {
        return;
      }

      final {{#camelCase}}{{{name}}}{{/camelCase}}sById = state.asReady.{{#camelCase}}{{{name}}}{{/camelCase}}s
          .asMap()
          .map((_, value) => MapEntry(value.id, value));

      for (final change in changes) {
        if (change.wasDeleted) {
          {{#camelCase}}{{{name}}}{{/camelCase}}sById.remove(change.key);
        } else {
          {{#camelCase}}{{{name}}}{{/camelCase}}sById[change.key] = change.value!;
        }
      }

      final newState = _Ready({{#camelCase}}{{{name}}}{{/camelCase}}sById.values.toList());

      if (state == newState) {
        return;
      }

      add(_SourceChanged(newState));
    });
  }

  FutureOr<void> _sourceChanged(_SourceChanged event, _Emitter emit) async {
    emit(event.state);
  }
}
